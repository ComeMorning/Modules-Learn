## 一、变量、内存理解

- **变量**：用来标识 (identify) 一块内存区域。为了方便表示内存，我们操作变量实质上是在操作变量指向的那块内存单元。编译器负责分配。我们可以使用 Python 内建函数 id()来获取变量的地址

- **变量名**：是一个标识符 (dientify)，用来代之一块内存空间，使用这个变量名，我们可以很方便的操作这块内存区域。

- **内存：**内存是我们电脑硬件，用来存放数据，形象的理解就是内存有一个一个的小格子组成，每个格子的大小是一个字节，每个格子可以存放一个字节大小的数据。我们如何才能知道，数据存放在哪些格子中，那就得靠地址，地址类似于楼房的门牌号，是内存的标识符。


## 二、id（）

id(object) 函数是返回对象 object 在其生命周期内位于内存中的地址，id 函数的参数类型是一个对象。


## 三、is 和 == 是什么

官方文档中说 is 表示的是对象标示符（object identity），而 == 表示的是相等（equality）。is 的作用是用来检查对象的标示符是否一致，也就是比较两个对象在内存中的地址是否一样，而 == 是用来检查两个对象是否相等。

### Is 语句

比较的是两个对象的id值是否相等，我们在检查 a is b 的时候，其实相当于检查 id(a) == id(b)。

### == 语句

比较的是两个对象的内容是否相等，实际是调用了对象 a 的 `__eq()__` 方法，a == b 相当于 `a.__eq__(b)`。

## 四、数据池

>is 比较 id 是否是同一个内存

### 1、int  

> 范围 [-5, 256]，（不同python版本可能不一样）

```python
n1 = 256
n2 = 256
n1 == n2, n1 is n2
 # True True
```

```python
n1 = 257
n2 = 257
n1 == n2, n1 is n2
```

对于 257，n1 is n2 返回的竟然是 False(**坑**：交互IED里是False， pycharm里是True)，结果可能在你的意料之中，也有可能出乎你的意料，但不管怎么，我们还是要刨根问底，找出问题的真相。


#### 解惑一

出于对性能的考虑，Python 内部做了很多的优化工作，对于整数对象，Python 把一些频繁使用的整数对象缓存起来，保存到一个叫 small_ints 的链表中，在 Python 的整个生命周期内，任何需要引用这些整数对象的地方，都不再重新创建新的对象，而是直接引用缓存中的对象。Python 把这些可能频繁使用的整数对象规定在范围 [-5, 256] 之间的小对象放在 small_ints 中，但凡是需要用些小整数时，就从这里面取，不再去临时创建新的对象。因为 257 不再小整数范围内，因此尽管 a 和 b 的值是一样，但是他们在 Python 内部却是以两个独立的对象存在的，各自为政，互不干涉。

弄明白第一个问题后，我们继续在 Python 交互式命令行中写一个函数，再来看下面这段代码：

#### 片段一

```python
c = 257


def foo():
    a = 257
    b = 257
    print(a is b)
    print(a is c)


foo()
# True
# False
```

呃，什么情况，是的，你没看错，片段一中的这段代码 a、b 值都是 257 的情况下，出现了 a is b 返回 True，而 a is c 返回的 False，a、b、c 的值都为 257，为什么会出现不同的结果呢？这对于刚刚好不容易建立起来的认知就被彻底否决了吗，那这段代码中究竟发生了什么？难道解惑一中的结论是错误的吗？

#### 解惑二

为了弄清楚这个问题，我们有必要先理解程序**代码块**的概念。Python 程序由代码块构成，代码块作为程序的一个最小基本单位来执行。**一个模块文件、一个函数体、一个类、交互式命令中的单行代码都叫做一个代码块**。在上面这段代码中，由两个代码块构成，c = 257 作为一个代码块，函数 foo 作为另外一个代码块。Python 内部为了将性能进一步的提高，凡是在一个代码块中创建的整数对象，如果存在一个值与其相同的对象于该代码块中了，那么就直接引用，否则创建一个新的对象出来。**Python出于对性能的考虑，但凡是不可变对象，在同一个代码块中的对象，只要是值相同的对象，就不会重复创建，而是直接引用已经存在的对象**。因此，不仅是整数对象，还有字符串对象也遵循同样的原则。所以 a is b 就理所当然的返回 True 了，而 c 和 a 不在同一个代码块中，因此在 Python 内部创建了两个值都是 257 的对象。

#### 结论

1. **小整数对象 [-5,256] 是全局解释器范围内被重复使用，永远不会被 GC回收。**

2. **同一个代码块中的不可变对象，只要值是相等的就不会重复创建新的对象。**


### 2. str

> Python的字符串驻留机制： 驻留机制**与字符串长短无关**，每行字符串字面量都会申请一个新字符串，但是**只含大小写字母、数字和下划线**的会被intern，也就是维护了一张dict来使得这些字符串全局唯一

```python
a = "hello world"
b = "hello world"
a is b  # False
```

```python
a = "HelloWorld_123"
b = "HelloWorld_123"
a is b  # True
```

### list

```python
a = [1, 2, 3]
b = [1, 2, 3]
print(a is b)  # False
print(a == b)  # True
```

```python
a = [1, 2, 3]
b = a
print(a is b)  # True
print(a == b)  # True
```

```python
id([1,2,3]) == id([4,5,6])  # True
# 因为上一个 [1,2,3]被回收了 在新建[4,5,6]时那片缓存又被用到了
```

```python
# 交互模式下
[1,2,3] is [4,5,6]  # False
```

### py 文件

在一个 py 文件中，只要内容一样，内存就一样
