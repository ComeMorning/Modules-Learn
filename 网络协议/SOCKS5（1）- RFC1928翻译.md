# SOCKS5 协议(译)

## 一、前言

在之前在探究App抓包时，了解到SOCKS代理与http(s)代理的差异，感觉Socks代理更强大一些，它能代理任何TCP/UDP的协议，所以能抓到更多类型的的网络流量，因此在移动端抓包时，我通常会配合一些VPN代理APP，将网络流量封装为SOCKS协议后，再转发到Charles等支持SOCKS代理的抓包工具上。在其他的VPN代理场景中也会见到SOCKS的身影，甚至如果你正好有手写SOCKS5服务器的需求，那么一定要了解深入了解一下SOCKS协议的细节。

要深入学习Socks5协议，那肯定是要阅读原版RFC文档的，因为文档内容不多，所以我才有看完的勇气😁。顺便也找到了几篇他人的翻译文章，但是我认为很多地方翻译的不够准确，甚至是严重的翻译错误，故按照我的理解重新翻译了一遍，如有错误，欢迎评论指正。



英文原文： [RFC 1928: SOCKS Protocol Version 5](https://www.rfc-editor.org/rfc/rfc1928)

译者：[wanZzz](https://github.com/wanZzz6)

## 二、正文翻译

### 文档状态

本文件为互联网社区规定了一个互联网标准跟踪协议，并请求讨论和提出改进建议。有关本协议的标准化状况和状态，请参阅当前版本的"互联网官方协议标准"(STD1)。传播或者发布这份文档没有任何限制。

### 致谢

这份文档描述的协议是对此协议第 4 版 （socks 4）的改进。这一新协议源于积极的讨论和原型实现。主要贡献者如下马库斯-利奇(Marcus Leech):贝尔-北方研究公司、戴维-科布拉斯(David Koblas):独立顾问、Ying-Da Lee:NEC系统实验室、LaMont Jones:惠普公司、David Koblas：惠普公司、Ron Kuris:Unify公司、Matt Ganis:国际商业机器公司。

## 1. 简介

在因特网越来越普及的时候，防火墙的使用使得系统能轻易地将组织的内部网络结构与外部网络隔离。一般来说，防火墙充当了网络间的应用层网关的角色，提供受管制的 TELNET、FTP 和 SMTP 访问权限。为了更方便的信息沟通，越来越多的复杂的应用层网络协议被设计出来，有必要为这些协议提供一个通用框架，以便透明、安全地穿越防火墙。

同时，一种可行且强有力的（细粒度）认证也很重要。许多部门、复杂的组织关系，他们的网络需要合理地控制和强有力的认证，从这点不难看出这个要求的必要性。

这里描述的协议旨在为TCP和UDP域的客户端-服务器应用程序提供一个框架，以便方便、安全地使用网络防火墙的服务。从概念上讲，该协议是应用层和传输层之间的"垫层"，因此不提供网络层网关服务，如转发ICMP消息。

## 2. 现行协议

目前通用的协议为SOCKS版本4协议，可为基于TCP的客户端-服务器应用程序（包括TELNET、ETP以及HTTP、WAIS和GOPHER等流行的信息发现协议）提供不安全的防火墙穿透服务。
本协议扩展了SOCKS第4版模型，加入了UDP协议支持，并扩展了框架，使协议能够支持通用的几种强认证方案，并扩展了寻址方案，以包含域名寻址和IPv6寻址方式。
使用新协议需要重新编译或者重新链接原先基于TCP的SOCKS应用程序，以便使用SOCKS库中新封装的新特性。

> **注意**：
> 除非另有说明，在包格式示意图中出现的十进制数均为八位字节表示的相应字段的长度。
>
> - 当某个字节必须取特定值时，用语法X'hh'表示该字节的值。
> - 当某个域使用单词'Variable'时，这表示该域的长度是可变的，且该长度定义在一个和这个域相关联（1-2个字节）的域中，或某个数据类型域中。


## 3. TCP客户端流程

当 TCP 客户端想要建立必须透过防火墙（取决于具体的情况）的连接时，客户端必须与合适的 SOCKS 服务建立连接。SOCKS 服务默认监听 1080 端口，如果连接成功，客户端需要与服务端协商认证方式并完成认证，之后便可以发送中继请求。SOCKS 服务端会执行请求，要么建立起合适的连接，要么拒绝请求。



**客户端连接 SOCKS 服务器**，并发送版本标识符/方法选择消息：

 +----+----------+----------+
 |VER | NMETHODS | METHODS  |
 +----+----------+----------+
 | 1  |     1    |  1-255   |
 +----+----------+----------+

字段含义：
- `VER` 字段在本协议中设置为 X’05‘ 
- `NMETHODS` 字段是后面 `METHODS` 字段包含的方法标识符数量。
- `METHODS`：列出具体支持的方法标识符，数量在1-255之间不等。

目前已定义方法如下：

- X’00‘　　无需认证
- X’01‘　　GSSAPI
- X’02‘　　用户名/密码
- X’03‘-X’7F’　　IANA 指定
- X’80‘-X’FE’　　为私有方法保留
- X’FF‘　　无可接受方法



**服务端要从给定的方法列表中选择一个方法并返回选择报文**：

+----+--------+
|VER | METHOD |
+----+--------+
| 1  |   1    |
+----+--------+

字段含义：
- `METHOD` 字段如果为 X’FF‘， 则表示客户端列出的所有方法都不可接受，客户端收到此消息必须关闭连接。



如果返回了双方接受的方案，客户端和服务器就进入由选定的认证方案所决定的握手子进程（sub-negotiation），各方案所需的握手子进程的描述可以从它们的说明文档中查阅到。

如果开发者想要为自己的 METHOD 认证方案获取一个公开的方案号，可以联系IANA来分配。想要查看当前所有被分配的认证方案标识列表和它们所实现的具体协议，可以查阅ASSIGNED NUMBERS文档。

想要符合本SOCKS5协议的所有认证方案都必须支持GSSAPI，并且能够支持用户名/密码认证方式。

## 4. 请求

一旦认证方案所需的握手子进程完成，客户端就可以发送请求详情了。如果协商的认证方案要求对数据进行用于检查完整性或确保安全性的的封装，则请求消息必须以规定的格式封装。
SOCKS请求的格式如下：

+----+-----+-------+------+----------+----------+
|VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  | X'00' |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+

字段含义：

- `VER`:　协议版本（本协议为X'05'）
- `CMD`:　命令（具体含义见本文第6节）
  - CONNECT请求：X'01
  - BIND请求：X'02'
  - UDP ASSOCIATE请求：X'03'
- `RSV`:　保留字段
- `ATYP`:　地址类型
  - IPV4:　X‘01’
  - 域名:　 X‘03’
  - IPV6:　X‘04’
- `DST.ADDR:`　目标地址
- `DST.PORT`:　目标端口 （网络字节序）



S0CKS服务器通常会根据源地址和目标地址对请求进行评估，并根据请求类型返回一条或多条应答消息。

## 5. 寻址

`ATYP` 字段指定了地址字段（DST.ADDR/BND.ADDR）包含的地址类型：

- X‘01’：地址字段为一个 IPV4 地址，长度为 **4字节（32位）**
- X‘03’：地址字段为一个完整域名，且**第一个字节为域名长度标识**，不需要写终止符NUL
- X‘04’：地址字段为一个 IPV6 地址，长度为 **16字节（128位）**

## 6. 应答

一旦客户端与服务端建立连接并完成认证，客户端就会发送SOCKS请求消息，服务端分析请求内容，并返回如下格式的应答消息：

+----+-----+-------+------+----------+----------+
|VER | REP |  RSV  | ATYP | BND.ADDR | BND.PORT |
+----+-----+-------+------+----------+----------+
| 1  |  1  | X'00' |  1   | Variable |    2     |
+----+-----+-------+------+----------+----------+

字段含义：

- VER：本协议版本号（X'05'）
- REP：应答字段
   - X‘00’:　成功
   - X‘01’:　常规 SOCKS 服务故障
   - X‘02’:　违反规则的连接
   - X‘03’:　网络不可达
   - X‘04’:　主机不可达
   - X‘05’:　拒绝连接
   - X‘06’:　TTL超时
   - X‘07’:　命令不支持
   - X‘08’:　地址类型不支持
   - X‘09’-X’FF’:　未分配
- RSV　保留字段
- ATYP　地址类型
   - IPV4:　X‘01’
   - 域名:　X‘03’
   - IPV6:　X‘04’
- BND.ADDR:　服务端绑定地址
- BND.PORT:　服务端绑定端口



其中，标记为保留字段（`RSV`）的值必须设定为 X‘00’ 。

如果协商的认证方案要求对数据进行用于检查完整性或确保安全性的的封装，则应答消息必须以规定的格式封装。

### 6.1 CONNECT-连接请求

对于连接请求，返回的报文里面 `BND.PORT` 为服务端用来连接目标地址所使用的端口，而 `BND.ADDR` 则包含了对应的 IP 地址。这里`BND.ADDR`的IP地址通常与客户端访问SOCKS服务器时所用的IP不同，因为此类服务往往是多台机器提供服务。 我们建议SOCKS服务器通过分析`DST.ADDR`和`DST.PORT`字段以及客户端源地址/端口来分析CONNECT请求。

### 6.2 BIND-绑定请求

BIND请求通常用在某些客户端被动接收来自服务器的连接的协议上，例如 FTP 协议：通过 `客户端 -> 服务端` 的连接发送命令和状态报告，通过另一个 `服务端 -> 客户端` 的连接按需接收传输的数据（例如： LS, GET, PUT）。

建议客户端应用协议首先使用CONNECT请求建立主连接后，再使用BIND请求建后续连接。

建议SOCKS服务器使用`DST.ADDR`和`DST.PORT`评估BIND请求。

在BIND操作期间，SOCKS服务器会向客户端发送两个应答：

- 第一个应答在服务器创建和绑定了一个新的socket监听之后发送，`BND.PORT`和`BND.ADDR`字段分别包含SOCKS服务端等待外部连接所监听的端口号和IP地址。应用协议客户端应当使用这些信息通知应用服务端去建立连接（通过主连接或控制连接）
- 第二个应答会在预期的外部连接成功或失败后发送。 其中，`BND.PORT` 和 `BND.ADDR` 为请求连接的外部主机地址和端口。

### 6.3 UDP ASSOCIATE-UDP关联请求

客户端通过UDP ASSOCIATE请求在处理UDP报文的转发进程内建立一种关联（状态），这种关联（状态）关系会随着其对应发送UDP ASSOCIATE请求的TCP连接的终止而终止（就是控制UDP报文转发的启停）。

在请求中，`DST.ADDR` 和 `DST.PORT` 字段包含了客户端想要用来关联并发送UDP报文的**客户端**地址与端口，服务端可利用此信息在关联中施加访问控制。

如果客户端在发送UDP ASSOCIATE请求时不指定地址和端口信息，必须用全0来填充`DST.ADDR`和`DST.PORT`字段。

SOCKS服务器在应答UDP ASSOCIATE请求时，`BND.PORT`和`BND.ADDR`字段指明了客户端必须将UDP报文发送到该（转发服务器的）IP/端口上，从而完成UDP报文转发。

### 6.4 应答过程

当回复失败应答时（REP字段不为X'00'），SOCKS 服务端必须在发送完该应答后及时关闭 TCP 连接。从检测到发生故障的原因到切断链接，不能超过10秒。

当回复成功应答（REP字段为X'00'），并且请求类型为BIND或CONNECT时，客户端就可以立即发送数据了。

客户端发送数据时，如果前面协商的认证方案要求对数据进行用于检查完整性或确保安全性的的封装，则所有数据必须以规定的方法封装。同样的，当SOCKS服务端要转发数据到客户端时，也要用相同的方法进行封装。

## 7. 基于UDP的客户端的数据包转发过程

基于UDP的**客户端**必须把UDP报文发送到UDP ASSOCIATE应答报文中`BND.ADDR`/`BND.PORT`字段所指示的（转发服务器）地址/端口上。如果前面协商的认证方案要求对数据进行用于检查完整性或确保安全性的的封装，则报文必须以规定的方法封装。

每个 UDP 报文都携带一个请求头：

+----+------+------+----------+----------+----------+
|RSV | FRAG | ATYP | DST.ADDR | DST.PORT |   DATA   |
+----+------+------+----------+----------+----------+
| 2  |  1   |  1   | Variable |    2     | Variable |
+----+------+------+----------+----------+----------+

字段含义：

- RSV:　保留字段，应当置为 X‘0000’
- FRAG:　当前分片序号
- ATYP:　地址类型
  
  * IPV4:　X‘01’
  * 域名:　X‘03’
  * IPV6:　X‘04’
- DST.ADDR:　目的地址
- DST.PORT:　目的端口
- DATA:　用户数据

当UDP转发服务器决定转发一个UDP数据报时，它会静默执行，不会向客户端发送任何通知。同样地，当它收到无法转发的UDP数据报时，会直接丢弃，也而不会有任何通知。当UDP转发服务器接收来自远程主机的应答数据报时，它必须使用上面的UDP请求头部封装数据报，并且需要进行基于身份验证方法的封装（如果有）。

转发服务器必须从SOCKS服务器上获取UDP报文的源IP（UDP关联请求中的`DST.ADDR`），如果数据报来自一个与此的关联关系不同的IP，那么该数据报会被丢弃。正确的数据报将发送到UDP ASSOCIATE应答中给定的端口号。

`FRAG`字段表明这个数据包是否是多分片UDP数据报中的一片。在实现分片功能时，此字节最高位（>=128)表示分片结束；X‘00’ 表示此报文为独立数据包；1~127之间的值表示当前数据包在分片序列中的位置。

每个报文接收者应当为这些报文分片关联一个**重组队列**（REASSEMBLY QUEUE）和一个**重组计时器**（REASSEMBLY TIMER）。计时器必须大于5秒，每当计时器超时，或者收到乱序（`FRAG`值小于重组队列队尾报文分片的`FRAG`值 ）的数据报文分片时，都要重新初始化重组队列，并丢弃队列中已存储的报文分片。

尽管如此，但我们仍建议你在应用程序中尽量不使用分片功能。

在用代码实现SOCKS5协议时，分片功能是可选的；如果未实现分片功能，则收到所有`FRAG`字段不为X'00'的数据包必须被丢弃。

由于SOCKS实现在支持UDP转发时会在原始UDP数据区前增加一个SOCKS协议相关的头，因此UDP编程接口在开辟UDP报文发送缓存区时要为这个头留足空间：

|ATYP  | 头占用字节|
|:-:|:-:|
|X'01'| 10+ |
|X'03' | 262+ |
|X'04' | 20+ |

## 8. 安全性考虑

本文档描述了一种辅助应用层协议穿透 IP 网络防火墙的协议，其数据传输的安全性高度依赖于客户端与服务端协商后选定的认证方案，以及该方案的具体实现中，所采用的认证和数据封装方法。
## 9. 参考

[1] Koblas, D., "SOCKS", Proceedings: 1992 Usenix Security Symposium.

作者地址

       Marcus Leech
       Bell-Northern Research Ltd
       P.O. Box 3511, Stn. C,
       Ottawa, ON
       CANADA K1Y 4H7
    
       Phone: (613) 763-9145
       EMail: mleech@bnr.ca



---

相关文章：


- [SOCKS 5 协议抓包分析 - 光韵流转 (quarkay.com)](https://www.quarkay.com/code/394/SOCKS5-protocol-wireshark-capture-analysis)
- [Socks 5 协议解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/438521117)
- [socks5代理服务器协议的说明_socks5 udp_H-KING的博客-CSDN博客](https://blog.csdn.net/liujiayu2/article/details/51691778)